---
title: "R powered web applications with Shiny"
output:
  html_document:
    toc: true
---

```{r, eval=FALSE, echo=FALSE}
shinyapps::deployApp("X:/administrative/social_media/blogposts/r_shiny/app1", account="spatial")
```

Shiny is an incredibly useful tool that allows you to create interactive, data-driven web applications with R. With Shiny, you use the open-source R language to create a web application and Shiny compiles your code into the HTML, CSS and JavaScript needed to display your application on the web. Shiny can be used to create a static web page with various widgets but more importantly you can use Shiny to create an interactive web application capable of executing R code in the background.

Creating and running simple web applications is relatively easy and there are great resources for doing this. But when you want more control of the application functionality understanding the key concepts is challenging. To help you navigate the creation of satisfying Shiny applications we've assembled example code below that demonstrates some of the key concepts.

In order to run Shiny and follow the code on this post you should make sure you have RStudio software and the `shiny` R package.

## Shiny at it's simplest

In its simplest form, a Shiny application requires a server function to do the calculations and a user interface that the user interacts with. Below we have the simplest possible shiny app -- it shows nothing and does nothing but you can use the `shinyApp` function to launch the app and, voila!, a functioning web application created entirely in R.

For simplicity, we're creating our Shiny apps in this blog post as single file apps. In the past, Shiny required that you create two separate files (server.R and ui.R) but as of version 0.10.2 Shiny supports [single file applications](http://shiny.rstudio.com/articles/single-file.html) with both server and UI code in the same file. With bigger apps, of course, you will have far more than just one or even two files. 

In earlier versions of `shiny` the user interface required using a ui handler function (`shinyUI`) but this is no longer required. The `fluidPage` function defines the kind of layout we will be using -- fluid refers to the ability of your app to re-structure on the fly to support many screen dimensions. If you want to rigidly structure your page you can use `fixedPage` instead.

Depending what you want to do with your app, the `session` argument is not required but since you need it for some tasks we will include it.


#### The simplest possible app {.tabset}

The app panel looks blank but there is a shiny app there

##### Code

```{r, eval=FALSE, code=readLines("app0/app.R")}
```


##### App




## Layout your app


Under the hood, Shiny uses Twitter Bootstrap, a commonly used framework for designing webpages, to scaffold and provide some miminal styling. When you run the function `shinyApp()` your R code is essentially compiled to web-friendly languages HTML, JavaScript and CSS. You can take advantage of Shiny page template functions or you can essentially design your app from scratch. There is also a brand new option discussed below to use what are called htmlTemplates but here we will focus on the more common approach.

### Using predefined layout functions

As mentioned above, we will use a fluid design. For this example, we will take advantage of a Shiny template using the function `sidebarLayout` which creates a page with a sidebar and a main panel. You can review other layout options [here](http://shiny.rstudio.com/articles/layout-guide.html). In this example we're creating a sidebar with only one element, a level 3 header using the `h3()` function. Then, in the main panel we're adding a set of tabs using the container function `tabsetPanel` and the empty individual tabs using `tabPanel`.

We have not yet touched our server so the app does nothing but displays our layout.


#### Basic user interface {.tabset}

##### Code

```{r, eval=FALSE, code=readLines("app1a/app.R")}
```


##### App


### Adding elements with tags$xxx

It's easy to add HTML elements to your Shiny app using [HTML tags](http://shiny.rstudio.com/articles/tag-glossary.html). There are more than 100 HTML elements you can add to your page using the syntax `tags$OBJECT()` as in `tags$p()` for a paragraph or `tags$blockquote()`. For a limited number of these tags, the most common ones, there are helper functions that allow you to skip the `tags$` so, for example, a first tier header can be created with `h1()` -- but be careful, not all tags permit this.


#### Example app: using HTML tags {.tabset}

##### Code

```{r, eval=FALSE, code=readLines("app1d/app.R")}
```


##### App



### You can also layout using Bootstrap's grid system manually

If you're new to CSS creating your layout can be challenging and you would need to read https://getbootstrap.com/examples/grid/. When you're comfortable





#### Basic user interface {.tabset}

##### Code

```{r, eval=FALSE, code=readLines("app1c/app.R")}
```


##### App


## Style your app


### Use an existing "theme"

Bootstrap offers a number of themes that allow for a complete change of style with limited coding. The `shinythemes` package from RStudio allows you to take advantage of this capability. The only change you need to make is to add a line of code `theme=shinytheme("cosmo")` to your `fluidPage` function and the entire look of you app will change. In this particular example, you won't see much difference because the app is so simple, but with bigger apps the changes are significant.


Documentation [here](http://rstudio.github.io/shinythemes/). More detail [here](http://bootswatch.com/).


#### Basic user interface {.tabset}

##### Code

```{r, eval=FALSE, code=readLines("app1b/app.R")}
```


##### App


### Style yourself with CSS

If you want to use your own CSS have have three basic options: 1) With a two page app (ui.R and server.R) you can add a folder called www and the app will automatically read any CSS files you've included there. 2) You can include your CSS directly inline in the head of your app and 3) You can use the `includeCSS` function to reference a css file.




#### An example using inline CSS in the HTML head {.tabset}

##### Code

```{r, eval=FALSE, code=readLines("app90a/app.R")}
```


##### App



#### An example using inline CSS in the HTML head {.tabset}

##### Code

```{r, eval=FALSE, code=readLines("app90b/app.R")}
```


##### App






http://shiny.rstudio.com/articles/css.html







## More on the user interface: allow user input

At this point we have scaffolded our layout but have not added any elements that will allow our user interface to be interactive. Shiny has a wide array of input widgets (e.g., pull-down menus, checkboxes) that we can use to add this functionality. They have a nice widget gallery [here](http://shiny.rstudio.com/gallery/widget-gallery.html).

For this particular example, I'll want a slider range and text input and I'll put both of them in the sidebar panel. Note that both of these, and all widgets, have a unique input id (`inputId`). Careful, this often causes trouble -- the input ids **must be unique**.

We're still only focusing here on the UI so these widgets "work" but don't actually do anything because we have not touched the server.


#### Allow user input {.tabset}


##### Code
```{r, eval=FALSE, code=readLines("app2/app.R")}
```

##### App




## Hook up the server to listen for user input

Currently, our users can interact with our application all they want but our server is deaf and dumb. There is no code in the server to tell it to listen or react.

In order to listen, it needs to know what to listen to and this is where our unique input ids come in. Our widgets all have a unique ID that we set above that the server can use to identify and listen to. Each of these input ids is mapped to the `input` argument on our server. So, for example, if you want to access the value of the text box we created (which is called `mytext`) from within the server you would call `input$mytext`. Likewise, for the slider the values are in `input$myslider`.

But... and this is one of the most challenging concepts in Shiny, you can't simply call `input$mytext` to get the current value of the text box -- **you need to wrap these "reactive" values in one of the functions designed to handle interactive widget output**, a reactive or observer.


## The Shiny hearing aids: `observe`, `reactive` or `render*`

The values associated with your UI inputs (like the text box, `input$mytext`) are called reactive elements. It is tempting to include `input$mytext` directly. Try running the code below and you will get an error `operation not allowed without an active reactive context` meaning that to read the reactive you need to wrap it in a function designed to listen to the reactive elements. Note that if you run this code (and get the error) you'll need to click on the "stop" button in the console to stop the app.



#### Hook up server {.tabset}


##### Code
```{r, eval=FALSE, code=readLines("app3/app.R")}
```
##### App



Instead we need to wrap the values in an `observe`, `reactive` or `render*` function that is designed to handle reactive content. 


### `observe` or `observeEvent`: wrap the reactive value in an observer if you want side effects (and don't need output)

Observers will get triggered in response to reactive values. They were designed to listen to reactive elements and respond by causing side effects, like updates to text boxes or pull-downs. Unlike the `reactive` function, they do not return data or values.

There are two flavors of `observe`. With `observe` the code inside will get triggered when any of the reactive values inside change. With 'observeEvent` code will only be triggered by specified reactive values.

So, back to the example, if we wrap the `print` statement in an observer the app will print the value of the text box to the console. In this example we're printing to the console only, not yet back to the ui.



#### Reactive values {.tabset}


##### Code
```{r, eval=FALSE, code=readLines("app4/app.R")}
```
##### App


`

As mentioned above, the code in an `observe` will run if *any* of the reactives inside change. So in the following code both print statements will run when either reactive changes.

```{r, eval=FALSE}
server <- function(input, output, session) {
  # both print statements will run when EITHER reactive
  # changes
   observe({
    print(input$mytext) 
    print(input$myslider)
    })
}
```

But with `observeEvent` the code inside will only run if the specified reactive value changes. So in the following code the print statements will only execute if the user makes changes to the text box.

```{r, eval=FALSE}
server <- function(input, output, session) {
  # both print statements will run when EITHER reactive
  # changes
   observeEvent(input$mytext, {
    print(input$mytext) 
    print(input$myslider)
    })
}
```



### `reactive`: isolate code and generate output with no side effects

A `reactive` is used in the same way you would use an R function except that it gets triggered by a reactive element. Because using `reactive` creates a function and returns results you generally save as an object and use it elsewhere in your server as you would use any R function with the very important exception that it can only be run within a "reactive context" (so in another reactive, an observer or a render* function) . The reactives are NOT supposed to generate side effects, they should essentially be self-contained.

So in the example, below I use `reactive` to create a self-contained function called `myresults`. Since I want to print the results to the console (a side effect), I run the reactive function from within an observer. Note that since it's a function I'm using `myresults()` rather than just `myresults`.


#### Using reactive() {.tabset}


##### Code
```{r, eval=FALSE, code=readLines("app5/app.R")}
```
##### App



### `render*` and `*Output`: To create a display text, tables, plots and user interface elements.

The third type of listener is designed to create items to add to your user interface. In the previous mini-apps we listened and reacted to reactive values with `observe` or `reactive` but simply printed to the console. But this is not that useful and will not keep your users entertained for long. We need to be able to return values to the user and this is where we use the set of render and output function.

#### `renderText` and `textOutput` as the initial example

In order to return values to the user we need a strategy to (1) grab the values from the UI in the server; (2) process as necessary and then (3) return the result to the UI. To do this RStudio created a suite of functions that tag-team and circulate the value to and from the server. These are the `render*` functions and the `*Output` functions.

**The user-to-Server-back-to-user process in broad strokes**:

1. The `renderText` function, in the server, would be used in the server to read the text box input (and process as necessary). 
2. Then the `renderText` function would send the result back to the user (the UI).
3. The UI would read in the output from the server using the `textOutput` function.

**The user-to-Server-back-to-user process a little more detail**:

Using our own app as an example. Let's say that instead of printing the text to the console we want to print it for our users. In order to do this we need to "complete the loop" with our UI which amounts to this:

1. Our UI has a text input called `mytext`
2. We will grab that value in the server inside the `renderText` function as `input$mytext`
3. Within the `renderText` function we can process `input$mytext` as necessary and then return the result to the UI.
4. In order to return the result to the UI from the server we name it and attach it to the output object (`output$myoutputtext <- something`).
5. In the UI we use the `textOutput` function to read in `myoutputtext` and put it on the UI

Give this a try, type something in the text box.



#### Using render and output {.tabset}


##### Code
```{r, eval=FALSE, code=readLines("app6/app.R")}
```
##### App



#### Spice things up with `renderPlot` and `plotOutput`

Similar to the `renderText` and `textOutput`, the `renderPlot` and `plotOutput` functions will create an object, in this case a plot, and then add that object to the user interface. Also similar to the text example, the objects move from the UI to the server and back to the UI.

Run the code and click on the plot tab to see the plot.



#### Add a plot {.tabset}


##### Code
```{r, eval=FALSE, code=readLines("app7/app.R")}
```
##### App



#### Dynamic UI widgets with `renderUI` and `outputUI`


More often than plain text or even a nice plot, you're likely to want to output new and altered HTML elements. In this case, instead of using `renderText` and `textOutput` you would use the `renderUI` and `uiOutput` pair of functions. In this example, the user input in the textbox gets appended to a pulldown menu. (This example does not remember previous input, this is discussed in another section below).

In `renderUI` you will often be returning more than one element for the UI, perhaps a title and a select box. With multiple elements, rather than returning a single element you return a `list` or `tagList` of elements

By the way, within `renderUI` if you want to include multiple elements you would include them all within a list function in R. As in `list(selectInput...., radioButtons...)`.




#### Dynamic user interface {.tabset}


##### Code
```{r, eval=FALSE, code=readLines("app8/app.R")}
```
##### App





### Putting all three listeners together

In the example below I'm including one typical use case for each of the three listeners. In a later example, I will link them together in a more meaningful way but there is one more topic I want to cover before I do that.


#### All three listeners {.tabset}


##### Code
```{r, eval=FALSE, code=readLines("app8/app.R")}
```
##### App



## Triggering listeners with reactive values

In our examples above, we included a reactive value (`input$mytext`) in `observe` or `reactive` or `render`. Each time the user changes the text value the server prints the result to the console. No problem.

But what if (A) you have no reactive value in an `observe` function or (B) your reactive value IS in the `observe` function but does **absolutely nothing**?

### If there is no reactive values the code will run once

If the `observe` (or `reactive` or `render*`) funcion has no reactive value inside it, it will run when you launch the app but never again. So in this server code the values 1-10 will print to the console once and then never again. 

```{r, eval=FALSE}
# this will work. it prints the value to the console
server <- function(input, output, session) {
  observe({
    print(1:10) # will not run more than once
    })
}

```

### If there is a reactive value the code will run with each change

Conversely, if you include a reactive value in an `observe` (or `reactive` or `render`) function the code inside will be triggered everytime the reactive value changes **even if that reactive values is not used in any calculations**. So in this code you can see that `input$mytext` is not actually part of the print statement -- it's not used. Nevertheless, any time your user changes the text box this server will print 1 to 10. This is a very important concept -- a reactive in your `observer` or `reactive` functions will trigger that function to run if the user interacts with it even if the reactive element is not part of the calculations.


```{r, eval=FALSE}
# this will work. it prints the value to the console
server <- function(input, output, session) {
  observe({
    input$mytext
    print(1:10) # will run every time "mytext" changes
    })
}

```


## Isolate blocks of code using `reactive` so they only run when needed

Reactive functions are also a way to isolate your code and ensure that code is only running when you want it to run. Take for example, the following code. I have included the reactive associated with both the slider and the text input in the same observer. As a result, even if the user only changes the slider, the code associated with the text input will also get run

**Here all code in the observer run when the user changes either the text box or slider** 

#### Not ideal {.tabset}


##### Code
```{r, eval=FALSE, code=readLines("app9/app.R")}
```
##### App



**Here all code in the observer run when the user changes either the text box or slider** 

#### All code runs with change to text or slider {.tabset}


##### Code
```{r, eval=FALSE, code=readLines("app10a/app.R")}
```
##### App




#### Only relevant code runs with change to text or slider {.tabset}


##### Code
```{r, eval=FALSE, code=readLines("app10b/app.R")}
```
##### App



## Use `isolate` to stifle reactions


In our example above, we separated code into discrete chunks using the `reactive` function but what if you need to **use** a value but don't want to re-run code everytime that value changes?



#### The example app: Use isolate to avoid triggering reactions {.tabset}


##### Code
```{r, eval=FALSE, code=readLines("app11/app.R")}
```
##### App




## Create re-useable UI elements


Let's say you have an app that puts the same element in multiple tabs. Perhaps you have a variable select box that needs to be on 10 different tabs. You can create it once and then copy and paste it onto the other tabs but this presents several issues:

1. What if you want to make changes -- you'd need to make 10 changes.
2. Shiny requires that your elements all have unique IDs so you'd need to come up with a naming scheme. Perhaps select1, select2 etc...
3. Copy paste is a pain and prone to error!

As an alternative, you can create a function that outputs the UI elements you need and then, instead of repeating the code that creates those elements you can simply call the function. So in the example below, I create a function to generate a title, select box, radio buttons and a checkbox. Then I call that function three times -- one each for the tabs.



#### The example app: Create re-useable UI elements {.tabset}


##### Code
```{r, eval=FALSE, code=readLines("app11/app.R")}
```
##### App



## Deploy your app



## Add-in packages

### shinyBS



### shinyjs



### shinyURL
https://github.com/aoles/shinyURL



## Advanced topics


### DataTables

Adding interactive tables to your Shiny app is easier than you think. The original version of the shiny package included a renderDataTable function but this is slowly being deprecated in favor of the renderDataTable function from the package DT. For the purposes of simply showing a table the two options are very similar but DT extends the styling and interaction capabilities -- take a look at the [documentation](https://rstudio.github.io/DT/shiny.html). 

#### Example app: Using the shiny package for an interactive table {.tabset}


##### Code
```{r, eval=FALSE, code=readLines("app13a/app.R")}
```
##### App



#### Example app: Using the DT package for an interactive table {.tabset}


##### Code
```{r, eval=FALSE, code=readLines("app13b/app.R")}
```
##### App



### Interactive plots and maps


HTML widgets allow you to use JavaScript visualization libraries to create interactive graphics in R, including Shiny web applications. For details on HTML widgets generally you can visit [the site](http://www.htmlwidgets.org/). Below I show three examples, two examples of interactive plots (`plot.ly` and `highcharts`) and an interactive map with `leaflet` but there are many other widgets available.



#### Example app: Use plot.ly to make a ggplot interactive {.tabset}

Details on using plot.ly can be found at [this site](https://plot.ly/r/shiny-tutorial/).

##### Code
```{r, eval=FALSE, code=readLines("app14a/app.R")}
```
##### App


#### Example app: Use highcharts to make an interactive plot {.tabset}

Details on using highcharts can be found at [this site](http://jkunst.com/highcharter/).

##### Code
```{r, eval=FALSE, code=readLines("app14b/app.R")}
```
##### App




#### Example app: Use leaflet for an interactive map {.tabset}

Details on using leaflet in R can be found at [this site](http://rstudio.github.io/leaflet/shiny.html). If you want to interact between your map and app see [this example](http://urbanstudies.tcu.edu/research/open-data/tx-demographics/) by Kyle Walker and the [code used to create it](https://gist.github.com/walkerke/4988b5164258917687cb).

##### Code
```{r, eval=FALSE, code=readLines("app14c/app.R")}
```
##### App





### Shiny modules

At the Shiny Developers Conference Joe Cheng from RStudio gave a great presentation on Shiny modules. They are designed, in part, to help solve the issue of re-useability discussed above. The idea behind a module is very similar to the functions above that take, as an input, the unique id to be used on the element on your page.

As an example let's say you you're using a slider and two plots in several places in your application


1. Create the module UI
2. Create the module server
3. Create your Shiny UI and include the module UI inside
4. Create your Shiny server and include the module server inside

#### 1. Create the module UI

The module UI, unlike the app UI, is simply a function. It needs to have at least one argument, the `id` which is essentially just text that gets prepended to the UI element IDs. So in the example below the function is called `scatterUI` and we have three elements, `slider1`, `plot1` and `plot2`. If the user runs this function with `scatterUI("myapp")` the ids will become `myapp-slider1`, `myapp-plot1` and so on. This is powerful


```{r}
# MODULE UI
scatterUI <- function(id) {
  ns <- NS(id)
  list(
  fluidRow(
    column(6, offset=4,    sliderInput(ns("slider1"), label = "Limit the number of points ", min = 0, max = 32, value = 15))
           ),
  fluidRow(
    column(6, plotOutput(ns("plot1"))),
    column(6, plotOutput(ns("plot2")))
  )
  )
  
}
```







```{r}
library(ggplot2)

scatterUI <- function(id) {
  ns <- NS(id)
  list(
  fluidRow(
    column(6, offset=4,    sliderInput(ns("slider1"), label = "Limit the number of points ", min = 0, max = 32, value = 15))
           ),
  fluidRow(
    column(6, plotOutput(ns("plot1"))),
    column(6, plotOutput(ns("plot2")))
  )
  )
  
}


scatter <- function(input, output, session, dat, var1, var2, ptsize, col1, col2) {
  browser()
    dat <- dat[order(dat[[var1]]),]
    
  dat <- reactive({
    dat[1:input$slider1,]
  })
  
  output$plot1 <- renderPlot({
    ggplot(dat(), aes_string(var1, var2)) + geom_point(color=col1, size=ptsize)
  })

  output$plot2 <- renderPlot({
    ggplot(dat(), aes_string(var1, var2)) + geom_point(color=col2, size=ptsize) 
  })

  
}



ui <- fluidPage(
  
  scatterUI("prefix"),
   scatterUI("prefix2")
  
)


server <- function(input, output,session){
  
  
  callModule(scatter, "prefix", cars, "speed", "dist",  2, "red", "blue")
  callModule(scatter, "prefix2", mtcars, "mpg", "hp", 4, "forestgreen", "purple")
  
}

shinyApp(ui, server)



```




### htmlTemplates





```{r echo=TRUE}
sessionInfo
```


